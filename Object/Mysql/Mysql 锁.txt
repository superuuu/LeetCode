/** 根据锁的粒度划分 全局锁、表级锁、行级锁 */





死锁
    * 两个事物均持有锁，且需要对方持有的锁，发生死锁，死锁后的策略
        1、直接进入等待直到超时，可以通过innodb_lock_wait_timeout 来设置 (默认50s)
            // 超时时间过长影响性能，过短如果是简单的锁等待会出现很多误伤
        2、进行死锁检测，死锁监测机制发现死锁后会回滚其中一个事物(innodb_deadlock_detect)
            // 将并发的一行改成逻辑上的多行，余额数据行改成10行数据之和为余额，更新时随便更新一条，冲突概率降为1/10(视情况)

两阶段锁协议
    : Innodb事物中，行锁是在需要的时候才加上的，但不是不需要就立即释放，而是在事物提交之后一起释放的，此为两阶段锁协议

优化
    * 事物中有3条sql，将最有可能冲突的sql放到事物最后执行，尽可能减少锁等待时间
    * 将并发的一行改成逻辑上的多行，余额数据行改成10行数据之和为余额，更新时随便更新一条，冲突概率降为1/10(视情况)

故障及问题思路
    1、mysql每秒执行不到100个事物，但是cpu使用接近100%
        * 死锁检测， 死锁检测的复杂度是O(pow(n,2))    10000, 会出现事物执行很少，但是cpu很高的情况