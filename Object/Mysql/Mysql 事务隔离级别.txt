/** 事物隔离级别 */
    * 读未提交   read uncommited       => 脏读
    * 读提交    read commited(RC)      => 不可重复读
    * 可重复度   repeatable read (RR)  => 幻读
    * 串行化

1、RC和RR的实现机制是什么？
    MVCC (多版本并发控制 Multi Version Concurrency Control), 底层实现为版本链 + 快照(read view)

    区别：
        RC隔离级别下：每次执行select语句时都会生成一个read view
        RR：在执行第一个select语句执行时生成一个read view

2、RR
    start/begin transaction 启动事物，一致性视图是在第一次读的时候生成(select)，事物的真正启动是在第一次对db操作的时开启的
    start transaction with consistent snapshot 启动事物，在命令执行时即生成一致性视图

    视图数组：事物开启的瞬间会向系统申请事物ID，生成一个视图数组，数组中保存了当前系统中活跃的(事物开启了但是未提交的)事物ID
    高低水位：上面数组中最小事物ID为低水位，标识事物ID小于此值的都为已经提交的事物，可见
            系统中当前最大的事物ID+1被称为高水位，事物ID大于高水位的为未来开启的事物，不可见

    * 读取数据是读取最新版本，根据当前视图数组和当前读数据的row trx_id，进行判断，如果当前row trx_id 大于高水位则不可见，rowtrx_id回退一个版本，直到数据可见
    * 数据的row trx_id 标记的是哪个事物修改的，与顺序无关
    * 开启事物更新 k=k+1 where id =1 ,但是在更新前被其他事物也执行了+1操作，更新的时候会进行先读后写，此时的读会读到其他事物更新的值，也叫做当前读
    * 可重复读的核心就是 一致性读； 更新数据时只能够用当前读；当更新的数据行的行锁被其他事物持有，当前事物需要阻塞到其他事物锁释放

    * Innodb的行数据存在多个数据版本，每个数据版本有其row trx_id,每个事物有其自己的一致性视图，一般的读操作为一致性读，一致性读会根据row trx_id 和一致性视图来判断数据的可见性


3、在可重复读隔离级别下，事物在开始的时候会创建秒级别的全库快照，为什么这么快？
    * 实际上的快照其实是获取当时活跃的事物ID和当前系统内最大的事物Id，和数据量多少没关系

4、一致性视图
    * 事物启动时，会将当前的活跃事物放到数组里面，数组的最小值叫做低水位，当前系统最大的事物ID 叫做高水位，高水位和事物ID数组共同构成一致性视图 read-view
    * 数据版本的可见性就是根据数据的row trx_id 和一致性视图比对来判断数据的可见性的

5、select * from t where id = 1 for update;  select * from t where id = 1 share in mode;  均为当前读

6、RR隔离级别下幻读的问题
    1、在RR隔离级别下，如果使用的是快照读，那么幻读的问题是被解决了
    2、当前读是存在问题的，解决方式是next-key-lock(是行锁和间隙锁的组合)， 会锁住指定行和间隙

