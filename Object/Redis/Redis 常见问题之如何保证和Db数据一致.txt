/** 当引入缓存后，最常见的问题就是如何保证和后端数据库数据一致 */

三种方案：Cache Aside、Read/Write Throught和Write Back

1、cache Aside (只读模式)
    * 当访问命中缓存时，直接返回
    * 当访问未命中缓存，从db加载进缓存，再返回
    * 写操作直接更新db，然后删除缓存

    优点：保证数据一致性
    缺点：写操作会清掉缓存，访问时需要从db重新加载进缓存

2、Read/Write Through 策略
    * 应用层的读写只需要操作缓存，不需要关注后端服务器，缓存层自动从数据库中加载或是写回数据库

    优点：对应用层比较友好，只需要对缓存进行操作读写即可
    缺点：需要缓存层支持和数据库的联动

3、Write Back (读写缓存+异步写回策略)
    * 写操作时，只写缓存
    * 读操作命中缓存直接返回，未命中缓存从db中加载进缓存，如果缓存已满，则需要将要淘汰的数据写入db再将数据加载进内存再返回

    优点：写操作飞快，只操作内存
    缺点：如果在未写回db时发生故障或是宕机，缓存中数据会丢失


/** 操作db或是缓存时异常了怎么办 */
1、将缓存key过期时间设置较短来减少影响
2、如果需要强一致性，可以使用两阶段提交(2pc)、三阶段提交(3pc)、消息队列等来保证


/** 先删缓存，再更新数据库； 缓存删除完成，数据库还没来得及更新的时候线程B读取数据 */
产生问题
    1、此时缓存无数据，线程B从db中加载数据进缓存中(其实此时的db尚未更新，加载进缓存的为旧值)
    2、次数如果其他线程访问，会命中缓存中的旧值
解决方案
    延迟双删：避免其他线程将未更新数据加载进缓存，在缓存删除之后，进行db更新，db更新后再删除一次缓存，从而解决问题


*** 删除缓存失败或是更新数据库失败导致数据不一致，应该进行重试（mq）机制确保成功
*** 在删除缓存，更新数据库这两步操作中如果有其他线程读取到旧数据，应对方案是延迟双删



