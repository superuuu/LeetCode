/** 缓存雪崩 */
// 大量请求透过Redis打到数据库上，数据库压力升高

1、原因
    a:大量缓存数据同时过期，导致大量请求直接打到Db，数据库压力瞬间飙升
    b:缓存实例故障宕机，导致大量请求打到Db
2、解决
    1):针对大量key同时过期导致雪崩的解决方案
        a: 如果业务场景允许，避免大量的key设置统一过期时间
        b: 如果业务需要，可以在过期时间上给随机上一个小范围的数，如1-3min来避免在同一时刻集体过期
        c: 服务降级，一旦发生雪崩，可以通过服务降级方式将一些非核心业务请求拦截，减少db压力
        d: 请求限流，监控一旦发现缓存异常，从前端入口处对流量进行拦截，使真正到达后端的请求量级为可承受范围，避免数据库乃至整个系统挂掉


/** 缓存击穿 */
1、原因：热点数据在缓存中，承担大量的请求访问，热点数据过期，导致大量请求打到数据库从而引发问题
2、解决：热点数据不设置过期时间(或者添加额外字段信息来做某些控制)

/** 缓存穿透 */
描述：访问的数据在缓存中没有，进行db查询，db中也没有，导致大量请求不断透过缓存层查询db，缓存成了'摆设'

1、原因
    a : 业务层误操作，缓存和db中的数据被删除
    b : 恶意攻击，故意访问不存在的数据
2、解决方案
    a : 缓存空值，和业务层约定对不存在的数据访问进行缓存
    b : 布隆过滤器进行过滤，即使穿透，流量在缓存层和布隆过滤器层面过滤后也不会打到db层
    c : 前端校验，部分穿透是恶意攻击，前端在判断参数非法、不存在等场景式直接将请求拦截，避免后端被高频访问（IP封禁）

/** 布隆过滤器 */
由一个初始值都为0的bit数组和多个(n)hash函数构成
    * 当一个数x被写入数据库时，会经过多个(n)hash函数进行计算，得到n个数据
    * 用hash计算得到的数据对bit数组长度进行取模，得到每个哈希值在数组中的位置
    * 将对应位置的值设置为1

    * 查询时，按照上面的流程对查询数据进行计算，如果n个bit位的值均为1证明数据存在，有一个bit位不为一，认为数据不存在

    问题：布隆过滤器的误判(误判原因：哈希冲突)
        因为有可能不同的值经过hash运算后得到相同的bit组，导致误判，但是业务基本无影响，存在少量的穿透，大量请求还是被过滤掉的
    解决：扩大bit数组，增加hash函数
        引入问题：扩大bit数组意味着耗费更多的空间；增加hash函数意味着性能变差；