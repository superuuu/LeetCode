** Redis 的网络IO和键值对的读取是单线程，集群间数据同步、异步删除、持久化等是有其他线程完成（严格来说不是单线程）

为啥这么快？
    1：基于内存操作
    2：定制化的数据结构
        当保存64位有符号整型时，string会使用int来存储，int编码

        String      简单动态字符串
        List        双向链表、压缩列表
        Hash        压缩列表、哈希表
        Set         整数数组、哈希表
        Zset        跳表、压缩列表


    3：单线程避免上线文切换的开销；也避免了资源之间并发竞争和锁的问题
    4：IO多路复用机制使得Redis可以高效处理多个客户端请求

/** 多路复用的 IO 高性能模型 */
    * 简单来说就是一个线程处理多个IO流 (select/epoll 机制)
    * Redis内核允许同时存在多个监听套接字和已连接套接字，内核会一直监听这些套接字上的连接或是数据请求，一旦有新请求到达，
        就将请求交给redis线程去处理，从而实现一个Redis线程处理多个IO流
    * 为了请求到达时能通知到Redis线程，select/epoll 提供了基于事件的回调机制(针对不同时间调用不同的处理函数)


Redis 单线程处理请求的瓶颈
    1、任意一个请求在server中耗时过高，都会影响整个server性能
        a : 大key操作，写、删除
        b : 大量key集中过期，Redis的过期机制是在主线程执行的，大量key集中过期，单个请求会耗费时间在key的删除上
        c : aof 开启always，写盘速度远低于内存操作，会拖慢性能
        d : rdb 快照生成依赖主线程fork子线程，数据量越大，fork越耗时，主线程阻塞时长越长

举例：Get请求
    1、等待客户端的请求 bind/listen
    2、和客户端建立链接 accept   如果一直建立不成功会阻塞
    3、从socket中读取recv       等待客户端请求内容，会阻塞
    4、解析客户端数据请求parse
    5、根据请求类型读取数据 get
    6、返回给客户端数据(即向socket中写回数据)send

    2、3 accept、recv是潜在的阻塞点，但是socket模型支持非阻塞模式
    * socket方法会放回主动套接字，调用listen方法会转换为监听套接字，此时可以监听来自客户端的链接请求；最后调用accept方法，接受到达的客户端请求，并返回已连接套接字
    * 当accept 或是 recv无响应时，redis不用阻塞可以去做别的事情，IO多路复用机制登场
    * select/epoll 机制，redis内核允许同时存在多个监听套接字和已连接套接字，当有数据请求或是链接请求到来时，就会触发相应的事件，并放入事件队列，redis单线程对队列不断进行处理
    * select/epoll 机制提供了基于事件的回调机制，不同事件会触发不同的回调函数进行处理