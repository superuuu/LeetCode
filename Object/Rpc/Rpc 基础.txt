1、定义：RPC Remote Procedure Call 远程过程调用

          调用方                       提供方

动态代理    编解码     网络      网络      编解码      反射执行
     -序列化->   -编码->  -传输->   -解码->     -反序列化->

     反之亦然

2、RPC协议组成
    1、协议头   协议长度、序列化方式、消息ID、协议版本等内容
    2、协议体   请求方法、请求参数

3、RPC如何向后兼容，扩展的？
    使用Header中的扩展字段和Payload中的扩展字段来实现

4、序列化、反序列化
    序列化：调用方和服务提供方的出入参都是对象，对象不可以在网络中传输，需要转换成可以传输的二进制数据，并且该转换算法是可逆的，该过程成为序列化
    反序列化：服务提供方根据请求类型和序列化类型，将二进制的消息体逆向还原成请求参数对象， 该过程成为反序列化

5、常见序列化方式：
    1、jdk原生序列化
    2、JSON (卧槽...)
        json序列化问题
        a: json序列化开销成本较高，大数据量传输意味着需要大量的内存和磁盘使用
        b: json没有类型，对于强类型语言而言性能不会太好(反序列化性能差)
    3、Hessian
        动态、二进制、紧凑，性能较json、jdk更好，生成的字节数也更少
    4、Protobuf
        序列化后比json、Hessian更小，使用时需要定义IDL(Interface description language)
        序列化、反序列化速度更快


    文本类：xml、json
    二进制类：thrift、pb

    protobuf 速度快，需要静态编译  不支持null，不支持单纯的map、list等集合对象，需要包在对象里面
    java 速度慢，占用空间

6、当前业务使用的(顺丰同城)
    Json ， 优点是可读性好，跨语言，缺点是占用空间大

6.1 为什么要进行序列化？
    压缩数据，加快网络传输
    解决内存中数据结构到字节映射过程中如何保留各个结构和字段之间的关系

7、Rpc框架 如何选择序列化方式？
    * 性能、效率、空间开销(序列化后的大小，体积越小，传输速度越快，请求耗时越少)
    * 通用性、兼容性
        == 是否支持更多对象类型、是否支持跨平台、跨语言等
    优先级：安全性、通用性、兼容性、性能、效率、空间开销


    Hessian 的对象兼容性更好
    Protobuf 更高效、通用

8、RPC框架使用注意事项
    * 对象构造的过于复杂： 对象之间存在多层嵌套，对象越复杂，序列化反序列化的cpu消耗越严重，性能消耗越多，出问题概率更大
    * 对象过于庞大：有时遇到rpc超时可能是入参对象过于庞大，几兆字节
    * 使用序列化对象不支持的类型作为入参：如Hessian序列化方式传入LinkedHashMap等

9、服务端如何处理请求？
    同步阻塞(BIO)：客户端发起一个请求，服务端生成一个线程去处理，当请求过多导致线程数达到系统线程数上限时，新来的请求就无法处理了  适用于链接数较小的场景
    同步非阻塞(NIO)：使用IO多路复用技术，多个请求不用生成多个线程进行处理，可以节省系统开销    适用于聊天服务等
    异步非阻塞：客户端发起IO操作后立即返回，IO操作完成后客户端会收到通知，客户端无等待阻塞。 适用于连接数较高消耗比较重的场景