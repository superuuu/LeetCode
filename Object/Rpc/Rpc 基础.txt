1、定义：RPC Remote Procedure Call 远程过程调用

          调用方                       提供方

动态代理    编解码     网络      网络      编解码      反射执行
     -序列化->   -编码->  -传输->   -解码->     -反序列化->

     反之亦然

2、RPC协议组成
    1、协议头   协议长度、序列化方式、消息ID、协议版本等内容
    2、协议体   请求方法、请求参数

3、RPC如何向后兼容，扩展的？
    使用Header中的扩展字段和Payload中的扩展字段来实现

4、序列化、反序列化
    序列化：调用方和服务提供方的出入参都是对象，对象不可以在网络中传输，需要转换成可以传输的二进制数据，并且该转换算法是可逆的，该过程成为序列化
    反序列化：服务提供方根据请求类型和序列化类型，将二进制的消息体逆向还原成请求参数对象， 该过程成为反序列化

5、常见序列化方式：
    1、jdk原生序列化
    2、JSON (卧槽...)
        json序列化问题
        a: json序列化开销成本较高，大数据量传输意味着需要大量的内存和磁盘使用
        b: json没有类型，对于强类型语言而言性能不会太好(反序列化性能差)
    3、Hessian
        动态、二进制、紧凑，性能较json、jdk更好，生成的字节数也更少
    4、Protobuf
        序列化后比json、Hessian更小，使用时需要定义IDL(Interface description language)
        序列化、反序列化速度更快

6、当前业务使用的(顺丰同城)
    Yar，序列化方式Json、php(这个php是什么鬼)

7、Rpc框架 如何选择序列化方式？
    * 性能、效率、空间开销(序列化后的大小，体积越小，传输速度越快，请求耗时越少)
    * 通用性、兼容性
        == 是否支持更多对象类型、是否支持跨平台、跨语言等
    优先级：安全性、通用性、兼容性、性能、效率、空间开销


    Hessian 的对象兼容性更好
    Protobuf 更高效、通用

8、RPC框架使用注意事项
    * 对象构造的过于复杂： 对象之间存在多层嵌套，对象越复杂，序列化反序列化的cpu消耗越严重，性能消耗越多，出问题概率更大
    * 对象过于庞大：有时遇到rpc超时可能是入参对象过于庞大，几兆字节
    * 使用序列化对象不支持的类型作为入参：如Hessian序列化方式传入LinkedHashMap等

