/** Golang协程的核心机制是GMP */
    * G 代表goroutine协程 代码中go关键词创建的对象
    * M 代表 work thread 工作线程
    * P 代表处理器，用来管理和执行go routine

/** 理解不到位，可能存在错误 */

/** 调度器 */
1、调度器的功能是把可运行的GoRoutine协程(G)分配到可以工作的线程上(M)
2、调度器的组成包括处理器(P)、处理器维护的本地的Goroutine协程队列(G)、全局Goroutine协程队列;
3、调度器策略
    1): work stealing 当线程没有可运行的goroutine协程时，尝试从其他线程绑定的处理器(P)的本地队列偷取一部分到本地执行,如果还没有，会从全局队列获取
    2): hand off机制 当前线程被阻塞时，线程会释放绑定的处理器，由其他空闲的线程去继续执行
3.1 调度流程
    1) 从goroutine协程创建开始(go func())
    2) G会被优先保存到处理器(P)的本地队列中，如果本地队列满了，会把G保存到全局队列中
    3) 线程运行G协程时会优先从线程绑定的处理器的本地队列获取G，如果没有会从其他处理器本地队列获取，还没有会从全局队列获取
    4) 如果线程M在运行过程中发生阻塞，runtime会将绑定的处理器释放，如果有空闲线程，会复用让空闲线程去服务这个处理器，如果没有则会创建线程去执行
4、抢占式调度
    * 基于协作的抢占式调度
        * go语言在运行时发现goroutine运行超过10ms就会发出抢占请求stackpreempt
        * 当有函数调用时，会检查stackgurd0字段，如果已经变成stackpreempt，就会发生抢占让出当前线程
    * 基于信号的抢占调度(也称为异步抢占)
        *

5、GMP的数据量
    * G的数量无限制，受内存影响，一台普通机器可即可开启数十万个G
    * P启动时默认是cpu核心数量
    * M最大限制为1w


/** 进程、线程、协程 的区别 */
    * 进程，资源分配的最小单位，每个进程都有独立的内存空间，不同进程间通过进程间通信方式来通信
        1) 进程间通信方式：管道，通常指无名管道
        2) 进程间通信方式：FIFO，即命名管道，可以在无关的进程间进行通信
        3) 消息队列
        4) 信号量
        5) 共享内存(两个或是多个进程共享同一块内存)
    * 线程，程序执行的最小单位，是cpu调度的基本单位，从属于进程，同一进程内的线程数据共享
    * 协程，轻量级的线程，不受操作系统调度，协程的调度器由应用程序提供，协程调度器按照策略将协程调度到线程中执行

